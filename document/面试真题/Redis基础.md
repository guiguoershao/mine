#### 什么是redis
* key-value 数据库
* 性能高
* 原子性
* 丰富的数据类型（list set zet hash）
* 丰富的特性
* 持久化到磁盘中


#### Redis 有哪些适合的场景
* 会话缓存：必memcached更加持久
* 全页缓存：
* 队列：list set，有很多的开源项目
* 排行榜/计数器：redis在内存中对数字的递增和递减有很好的实现（集合和有序集合），
* 发布/订阅

#### 协程进程线程的区别

##### 进程
* 进程：进程有一个独立的地址空间有自己的堆，
* 操作系统已进程为单位，进程是资源分配的最小单位

##### 线程
* 线程是进程的实体，是cpu调度的基本单位，比进程更小
* 与同属一个进程的线程共享全部的资源
* 相对于进程不够稳定，容易丢失数据

##### 协程
* 协程是一种用户态的轻量级线程
* 操作协程的时候是没有内核切换的开销，不用消耗资源，不用枷锁的访问上下文资源


##### 进程和线程比较
* 地址空间：进程包含线程，共享地址空间，进程有独立的地址空间
* 资源：进程是资源分配和拥有的单位，同一个进程中的线程共享进程的资源
* 线程是处理器（cpu）调度的基本单位，但进程不是。

##### 携程和线程比较
* 一个线程可以有多个协程，一个进程也可以单独拥有多个协程
* 线程进程都是同步的，协程是异步的
* 协程能保留上一次调用时的状态

#### redis的数据类型和特点
##### 数据类型
* string 字符串
* hash 哈希
* list 列表
* set 集合
* zet 有序集合
* Hyperloglog
* pub/sub
* redis module

##### 特点
* 速度快、持久化
* 支持丰富的数据类型
* 支持事务
* 丰富的特性
* 缓存、消息、key过期时间

#### redis的持久化机制是什么？

##### RDB（Redis DataBase）
* 只有一个文件dump.rdb，
* 容灾性好，
* 性能最大化，
* 效率更高
* 数据安全性低
##### AOF（append-only file）
* 数据安全
* 解决数据一致性的问题
* rewrite模式
* AOF 必RDB文件大 恢复速度慢， 数据集大的时候比rdb启动效率低


#### Redis保存热点数据解析
* redis内存数据集大小上升到一定的时候，就会施行数据淘汰策略
##### volatile-lru 设置了过期时间的数据 挑选最近最少使用的数据淘汰
##### volatile-ttl 设置过期时间的数据 挑选将要过期的数据淘汰
##### volatile-random 设置过期时间的数据集中任意随机选择数据淘汰
##### allkeys-lru 从数据集中挑选最近最少使用的数据淘汰
##### allkeys-random 从数据集中任意数据淘汰
##### no-enviction 禁止驱逐数据

#### 假如Redis里面有一亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？
* 使用key指定可以扫除指定模式的key列表 (key XXX*)。 会阻塞
* scan指定，无阻塞的查看，可能会有重复，通过程序过滤重复的键


#### 使用过Redis做异步队列么，你是怎么用的？

* 一般使用list结构作为队列，rpush生产消息，lpop消费消息，当lpop没有消息时，适当使用sleep。

##### 可不可以不用sleep？
* 使用blpop,没有消息的时候会阻塞，直到消息的到来。


##### 一次生产多次消费
* pub/sub 订阅者模式，可以实现1:n（1对多）的消息队列

##### pub/sub订阅者模式的缺点
* 消费者下线的情况下，生产的消息会丢失

##### redis如何实现延时队列
* 使用sortedset 拿时间戳作为score，key调用zadd来生产消息，消费者用zrangebyscore指令来获取之前的数据进行轮训处理

* redisManger
```
class RedisManger
{
    private $redis;
    private $config = [
        'host' => '127.0.0.1',
        'port' => 6379
    ];
    public function __construct($redisConfig = [])
    {
        $redis = new Redis();
        $config = array_merge($this->config, $redisConfig);
        $redis->connect($config['host'], $config['port']);
        $this->redis = $redis;
    }
    public function zAdd($key, $score, $value)
    {
        $this->redis->zAdd($key, $score, $value);
    }
    public function zGet($key, $max)
    {
        return $this->redis->zRangeByScore($key, 0, $max);
    }
    public function zRemove($key)
    {
        return $this->redis->zRemRangeByRank($key, 0, 0);
    }
}
```
* 消费者
```
$redis = new RedisManger();
$key = 'test';
while (true) {
    $data = $redis->zGet($key, time());
    if ($data) {
        foreach ($data as $value) {
            # 执行逻辑
            echo $value . PHP_EOL;
            # 移除
            $redis->zRemove($key);
        }
    }
    sleep(1);
}
```
* 生产者
```
$redis = new RedisManger();
$time = time();
$redis->zAdd('test', time() + 50, "this is after 50 seconds");
$redis->zAdd('test', time() + 30, "this is after 30 seconds");
$redis->zAdd('test', time() + 40, "this is after 40 seconds");
```

#### Redis过期键的删除策略
* 定时删除（创建键的时候，同时创建一个定时器，当过期时间来临是执行键的删除操作）
* 惰性删除，（动态获取的时候去检查有没有过期）
* 定期删除，每个一段时间程序对数据库进行一次检查，检查过期键，至于要怎么删除，由算法决定。

#### 为什么redis 需要把所有数据放到内存中
* 为了最快的读写速度，然后将数据读到内存中

#### Redis 如何做内存优化？
* 散列表 （哈希hash）

#### Redis 回收进程如何工作的？



#### Redis 和 memcached的区别
* 1.redis 支持更多的数据结构
* 2.redis 可以持久化
* 3.key的字符长度限制不同
* 4.redis 单线程的模型，memcache 使用CAS保持并发数据一致性


#### 如何实现集群中的session共享存储
* 粘性session
* session 复制，session 变化，广播通知其他服务器变更
* session 共享，redis和memcache进行 session共享
* session 持久化，存储到数据库中，效率低。


#### 什么是rabbitmq？
* 采用了AMQP高级消息队列协议，
#### 为什么要使用rabbitmq?
* 在分布式系统下具备异步，肖峰，负载均衡等一系列高级功能
* 拥有持久化机制，进程消息队列中的信息也可以保存下来
* 实现了消费者和生产者之间的解耦
* 对于高并发场景下，采用消息队列可以使得同步访问变为串行访问，达到一定量的限流，利于数据库的操作
* 可以用消息队列达到异步下单的效果，排队中后台进行逻辑的下单。

#### Redis分布式锁应用场景及使用

##### 分布式锁的基本条件
* 互斥性，在仁义时刻，只有一个客户端能持有锁
* 不会发生死锁，及时有一个客户端在持有所得的期间崩溃而没有主动解锁，也能保证后续其他客户端能枷锁
* 洁玲还需系铃人，加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁个解了，不能误解锁

##### 什么是lua
* lua是一种轻量小巧的脚本语言，用标准c语言编写并以源代码形式开放，其设计目的是为了嵌入应用中，从而为应用程序提供灵活的扩展和定制功能



#### 面试题
##### redis 单线程为什么还能这么快
* 命令执行基于内存操作，一条命令在内存里操作的时间是几十纳秒
* 命令执行是单线程操作，没有现成切换的开销
* 基于io多路复用机制提升Redis的io利用率
* 搞笑的数据存储结构：全局hash表以及多种高效数据结构，比如：调表，压缩列表，链表等等

##### redis底层数据是如何用跳表来存储的？
* 跳表：将有序链表改造为支持近似“折半查找”算法，可以进行快速的插入、删除、查找操作。
* 有序集合-选用的就是跳表

##### redis key过期了为什么内存没释放
* set key 如果一开始设置了过期时间，而后面操作 set key 没有设置过期时间，那这个key的过期时间将会被擦除，永不过期。 这时你的redis中就会存在大量不过期的key，消耗过多的内存资源。
* redis对过期key的处理一般有惰性删除和定时删除两种策略。 惰性删除：当读/写一个已经过期的key时，会触发惰性删除，判断key是否过期，如果过期了直接删除掉这个key。定时删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期（默认每100ms）主动淘汰一批已过期的key，这里的一批知识部分过期key，所以可能会出现部分key已经过期但还没有被清理掉的情况，导致内存并没有被释放。

##### redis 没设置过期时间为什么被Redis主动删除了？
* 当Redis已用内存超过max_memory限定，厨房主动清理策略
* 主动清理策略在redis 4.0之前一共实现了6中内存淘汰策略，4.0后，又增加了2中策略。总共8种。

* a) 针对设置了过期时间的key做处理
* 1.volatile-ttl: 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。
* 2.volatile-random: 设置了过期时间的键中随机删除
* 3.volatile-lru: 挑选最近最少使用的数据淘汰
* 4.volatile-lfu: 最不经常使用
* b) 针对所有的key做处理：
* 5.allkeys-random: 所有键随机删除
* 6.allkeys-lru：最近最少使用，淘汰很久没被访问过的数据，以最近一次访问时间作为参考
* 7.allkeys-lfu：最不经常使用，最近一段时间访问次数最少的数据，以次数做为参考
* c)不处理
* 8.noeviction：不会提出任何书籍，拒绝所有写入操作并返回客户端错误信息

* 绝大多数情况我们都可以用lru策略，当存在大量的热点缓存数据时，lfu可能会更好一点。

##### 删除key命令会阻塞redis吗？
* 删除单个字符串类型的 key ，时间复杂度为O(1)。
* 删除单个列表、集合、有序集合或哈希表类型的 key， 时间复杂度为 O(M)，M为以上数据结构内的元素数量。
* 可能会阻塞redis，删除数量以及key的大小有关系。

##### Redis主从、哨兵、集群架构优缺点比较
* 
##### Redis 集群数据hash分片算法是怎么回事

##### Redis 执行命令竟然有死循环阻塞bug

##### Redis 持久化RDB、AOF、混合持久化是怎么回事？

* RDB快照：在默认情况下，redis将内存数据快照保存在名字为dump.rdb的二进制文件中。满足指定条件，在那个时刻把整个redis内存放到rdb快照文件里面去。比较耗费时间。命令 save：同步，阻塞其他命令。  bgsave:异步，能做到写时复制。 RDB快照 会导致数据丢失。

* AOF（append-only file）将修改的每一条指令记录进文件中（先写入os cache，每个一段时间fsync到磁盘）。可以配置redis多久才将数据同步到磁盘一次。【1.appendfsync always：每次有新命令追加到AOF文件时就执行一次同步，非常慢，也非常安全。 2.appendfsync everysec： 每秒同步一次，足够快，并且在故障时只会丢失1秒钟的数据。 3.appendsync no: 重复fsync，将数据交给操作系统来处理。更快，也更不安全的选择。】推荐也是默认的措施是每秒1次，这种同步策略可以兼顾速度和安全性。

* AOF 重写【bgrewriteaof】。配置：auto-aof-rewrite-min-size 64mb // aof文件至少要达到64M才会自动重写 auto-aof-rewrite-percentage 100 // 文件自上一次重写后文件大小增长了100%则再次重写。AOF重写 redis会fork出一个子进程去做，不会对redis正常命令处理有太多影响。


* redis 4.0后 混合持久化。 配置：aof-use-rdb-preamble yes。AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存放在一起，都写入新的AOF文件。

##### Redis 备份策略
* 写crontab定时调度任务，每小时都copy一份rdb或aof的备份到一个目录去，保留48小时
* 每天都保留一份当日的数据备份到一个目录中去，
* 每天把备份数据复制到另一台机器上，以防止机器损坏。

#### 什么是缓存穿透？缓存击穿？缓存雪崩？
##### 缓存穿透
* 缓存中查不到，数据库中也查不到。大量请求，导致数据库崩溃。
* 解决方案：1.对参数进行合法性校验 2.蒋书记中没有查到结果的数据也写入缓存。 这时要注意为了防止redis被无用的key占满，这类缓存的有效期要设置短一点。 3. 引入布隆过滤器，在访问redis之前判断数据是否存在。
##### 缓存击穿 
* 【单个】缓存中没有，数据库中有，一般是出现在缓存数据初始化以及key过期了的情况。他的问题在于，重新写入缓存需要一定的时间，如果是高并发场景下，过多的请求就会瞬间写道DB上，给DB造成很大的压力。
解决方案：1.设置热点缓存永不过期。这时要注意在value当中包含一个逻辑上的过期时间，然后另起一个线程，定期重建这些缓存。2.加载DB的时候，要防止并发。DB往redis中写入缓存的时候，枷锁，防止其他线程也同时写入。

##### 缓存雪崩
* 【非常多】缓存大面积过期，缓存中没有，数据库中有。
* 解决方案：1.把缓存的失效时间分散开 2.对热点数据永不过期









