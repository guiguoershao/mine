### Mysql索引、底层结构

#### B树和B+树之间的区别是什么？

#### B 树
* 叶节点具有相同的深度，叶节点的指针为空
* 所有索引元素不重复
* 节点中的数据索引从左到右递增排列

#### B+树 （B树的增强版）
* 非叶子节点不存储data，只存储索引（冗余），可以放更多的索引
* 叶子节点包含所有索引字段值
* 叶子节点用指针连接（双向指针 ），提高区间访问的性能。


#### MyISAM
* 存储分为三个文件 表结构（frm）、表数据（myd）、表索引（myi）。
* MyISAM索引文件和数据文件是分离的（非聚集）

#### InnoDB 索引实现（聚集）
* 表数据文件本身就是按B+Tree组织的一个索引结构文件。两个文件：表结构（frm）、表索引（ibd）
* 聚集索引：叶子节点包含了完整的数据记录。

##### 为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？ 
* 我的解释：聚集索引的叶子节点存储的是主键值，然后再跟进主键进行索引查询到数据，多了一次回表查询的操作。选用int整型，1. 因为mysql底层 B+树，每层的节点是按顺序排列的，整型排序肯定比字符串排序快。2.整型暂用的空间比字符串小，节省空间。3.使用自增的主键，主要是为了节省mysql底层B+树各个节点排序的资源的损耗，（如果不自增，mysql底层会帮你维护顺序），自增会按顺序增加（永远在后面增加），节点分裂的概率非常小。

* 为什么非主键索引结构叶子节点存储的是主键值？（一致性和节省存储空间）

#### mysql 聚簇索引和非聚簇索引的区别
* 聚簇索引（innodb）：建数据存储于索引放到了一起、并且是按照一定的顺序组织的，找到索引也就找到了数据，数据物理存放顺序与索引顺序是一致的。即：只要索引是相邻的，那么对应的数据一定也是相邻的存放在磁盘上的。
* 非聚簇索引（myisam）：叶子节点不存储数据、存储的是数据行的指针地址。也就是说根据索引查找到的数据行的位置再去磁盘查找数据，这个就有点类似一本书的目录，比如我们要找第三章第一节，那我们先找这个目录里面找，找到对应的页面后再去对应的页面看文章

##### 优势：
* 查询通过聚簇索引可以直接获取数据，相比非聚簇索引（非覆盖索引）需要第二次查询效率更高。
* 聚簇索引对于范围查找的效率更高，因为其数据就是按照大小排列的
* 聚簇索引适合在排序的场合，非聚簇索引不适合

##### 劣势
* 维护索引昂贵，特别是插入新行或者主键被更新导致要分页的时候。建议在大量插入新行后，萱仔负载较低的时间段，通过 optimize table优化表，因为被移动的行数据可能造成水平。
* 建议使用 自增主键，而非uuid。 uuid 排序困难、难以维护顺序，存储空间更大。

##### Hash 索引
* 对索引的key进行一次hash计算就可以定位出数据存储的位置
* 很多时候hash索引要比B+树索引更高效
* 但是 仅能满足 "=", "in", 不支持其他范围查询，所以慎用
* 存在hash冲突的问题，可能会多次遍历链表查找结果。


##### 索引设计的原则
* 查询更快、占用空间更小
* 1.是个索引的列是出现在where子句中的列，或者连接子句中指定的列
* 2.基数较小的类，索引效果较差，没有必要在此列建索引
* 3.使用短索引，如果字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间。
* 4.不要过度索引。索引需要额外的磁盘空间，降低写操作的性能。
* 5.更新频繁的字段不适合创建索引


### mysql存储引擎

#### InnoDB 存储引擎
* innodb 是mysql的默认事务性引擎，也是最重要、使用最广泛的存储引擎。

#### MYISAM存储引擎
* 在mysql5.1及之前的版本中是默认引擎
* 但是myisam不支持事务和行级锁，而且崩溃后无法安全恢复。
同时myisam对整张表枷锁，很容易因为表锁的问题导致典型的性能问题。

#### Memory 引擎
* memory表至少比myisam表要快一个数量级，数据文件是存储在内存中。
* memory表的结构在重启以后还会保留，但数据会丢失。
* memory表在很多场景可以发挥好的作用：用于查找（lookup）或者映射（mapping）表，例如将邮政编码和州映射的表。

#### MyISAM和InnoDB的区别是什么？
##### 1.innodb支持事务，myisam不支持事务
##### Innodb 支持外键，而myisam不支持
* 对一个包含外键的innodb表转为myisam会失败
##### innodb 是聚集索引，myisam是非聚集索引
* 聚簇索引的文件存放在主键索引的叶子节点上，因此innodb必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后在通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。
* 而myisam是聚集索引，数据文件是分离的，索引保存的数据文件的指针。主键索引和辅助索引是独立的。
##### innodb不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而myisam用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。
##### innodb 最小的锁例度是航所，myisam最小的锁例度是表锁。
* 一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。

### 数据库表设计，字段选择

##### 字段类型优先级 整型 》 data, time > enum char > varchar > blob, text
* 选用字段长度最小、优先使用定长型、数值型字段中避免使用"ZEROFILL"
* time: 定长运算快，节省时间，考虑失去，写sql不方便
* enum: 能约束值的目的，内部用整型来存储，单与char连查是，内部要经历串与值的转化
* char: 定长，考虑字符集和校对集
* varchar: 不定长，要考虑字符集的转换与排序是的校对集，速度慢
* text,blob: 无法使用内存临时表（排序操作只能在磁盘上进行）

##### 可以选整型就不选字符串
* 整型是定长的，没有国家/地区之分，没有字符集差异。
##### 够用就行不要慷慨
* 大的字段影响内存影响速度。
##### 尽量避免使用null
* null不利于索引，也不利于查询。
##### char与varchar选择


##### mysql中varchar（M）能存多少数据
* 65535 个字节

### 事务

##### 事务的基本特性
* 原子性：一个事务中的操作要么全部成功，要么全部失败。
* 一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态。
* 隔离性：一个事务的修改在最终提交前，对其他事务是不可见的。
* 持久性：一旦事务提交，所做的修改就会永久保存到数据库中。

#### 事务并发可能引发什么问题？
##### 脏读 （读未提交）
* 1.在食物A执行过程中，事务A对数据资源进行了修改，事务B读取了事务A修改后的数据。
* 2.由于某些原因，事务A并没有完成提交，发生了RollBack操作，则事务B读取的数据就是脏数据、
* 这种读取到另一个事务未提交的数据的现象就是脏读（Dirty Read）。

##### 不可重复度
* 事务B 读取了两次数据资源，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的数据不一致。
* 这种在同一个事务中，前后两次读取的数据不一致的现象就是不可重复读（non-repeatable read）

##### 幻读
* 事务B 前后两次读取同一个范围的数据，在事务B 两次读取的过程中事务A新增了数据，导致事务B后一次读取到前一次查询没有看到的行。
* 幻读和不可重复读有些类似，但是幻读强调的是集合的增减，儿不是单条数据的更新。


**读取未提交（READ-UNCOMMITTED）：**最低的隔离级别，允许读取尚未提交的数据变更，可能造成脏读、不可重复读、幻读。
**读取已提交（READ-COMMITTED）：**允许读取并发事务已经提交的数据，可以避免脏读，但是可能造成不可重复、幻读。
**可重复读（REPEATABLE-READ）：**对同一字段多次读取的结果都是一致的，除非本身事务修改，可以避免脏读和不可重复读，但是可能造成幻读。
**可串行化（SERIALIZABLE）：**最高的隔离级别，完全服从ACID的隔离级别，所以的事务依次执行，可以避免脏读、不可重复读、幻读。

### 简单描述mysql各种索引
* 主键索引、普通索引、前缀索引

##### 主键索引
* 简历在主键上的索引成为主键索引，一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。

##### 唯一索引
* 简历在unique字段上的索引被成为唯一索引，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个控制不会发生重复冲突。

##### 普通索引
* 简历在普通字段上的索引被称为普通索引


##### 前缀索引
* 前缀索引是指对字符类型字段的前几个字符或对二进制类型字段的前几个bytes简历的索引，而不是在整个字段上建索引。前缀索引可以建立在类型为char、varchar、binary、varbinary的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。
* 前缀索引是一种能使索引更小更快的有效方法，但是也包含缺点：mysql无法使用前缀索引做 order by 和group by

##### 如何提高insert的性能

* 合并多条insert为1条，检查磁盘io，降低日志刷盘的数据量和频率（mysql的binlog和innodb的事务日志），从而提高性能。
* 修改参数 bulk_insert_buffer_size, 调大批量插入的缓存
* 设置innodb_flush_log_at_trx_commit = 0。 
* 手动使用事务，因为mysql默认是autocommit的，这样没插入一条数据都会进行一次commit；所以，为了检查创建事务的消耗，可以手工使用事务。将多个insert执行后一起commit。


### 什么是全局锁、共享锁、排它锁

##### 全局锁
* 全局所就是对整改数据库实例枷锁，他的典型使用场景就是做全库逻辑备份。这个命令使整改库处于只读状态。使用该命令之后，数据更新语句、数据定义语句、更新类事务的提交语句等操作都会被阻塞。

##### 共享锁
* 共享锁又称读锁（read lock），共享锁shared locks（S锁）也称读锁。是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行秀（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。
* select ... lock in share mode
* 对于使用共享锁的事务，其他事务只能读，不可写
* 如果执行了更新操作则会一直等待，直到当前事务commit或者rollback
* 如果当前事务也执行了其他事务处于等待的那条sql语句，当前事务将会执行成功，而其他事务会报死锁
* 允许其他锁共存

##### 排它锁
* 排它锁Exclusive Locks（X锁）也称写锁、独占锁：用于数据修改操作，例如insert、update或delete。确保不会同时对同一资源进行多重更新。
* select ... for update

* 对于排它锁的事务，其它事务可读，但不可进行更新操作
* for update仅使用与InnoDB，并且必须开启事务，在begin和commit之间才生效
* 当一个事务进行for update的时候，另一个事务也有for update时会一直等待，直到之前的事务commit或rollback或断开连接释放锁才能拿到锁进行后面的操作（排它锁不能共存）
* InnoDB引擎默认对update，delete，insert加排它锁，select语句默认不加锁
* 加过排他锁的数据行在其他事务中是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select … from …查询数据，因为普通查询没有任何锁机制

##### 谈一下mysql中的死锁
* 死锁是指两个或两个以上的进程在执行过程中，因增多资源而造成的一种互相等待的现象，若无外力作用，他们豆浆无法推进下去。此时成系统处于死锁状态或系统产生了死锁。

* 查看死锁：使用命令 show engine innodb status 查看最近的一次死锁。
* innodb lock monitor 打开死锁监控，每15s输出一次日志。使用完毕后建议关闭，否则会影响数据库性能。

* 策略1：通过innodb lock wait_timeout 来设置超时时间，一致等待直到超时;
* 策略2：发起死锁检测，发现死锁之后，主动回滚锁中的某一个事务，让其他事务继续执行。








